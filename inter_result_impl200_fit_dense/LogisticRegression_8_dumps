[297,
 703,
 ['handwritten_(3/3)', 297, 49, 654, 0, 0.8583815028901735, 1.0],
 ['docstrings_(1/5)', 297, 703, 0, 0, 0.297, 1.0],
 ['WPanalysis_(16/74)', 297, 0, 703, 0, 1.0, 1.0],
 ['C',
  'dual',
  'fit_intercept',
  'intercept_scaling',
  'l1_ratio',
  'max_iter',
  'multi_class',
  'penalty',
  'solver',
  'tol',
  'warm_start',
  'class_weight',
  'random_state',
  'verbose',
  'n_jobs'],
 {'learning_rate': 0,
  'loss': 0,
  'n_estimators': 0,
  'base_estimator': 0,
  'random_state': 0,
  'bootstrap': 0,
  'criterion': 0,
  'max_depth': 0,
  'max_features': 0,
  'max_leaf_nodes': 0,
  'min_impurity_decrease': 0,
  'min_samples_leaf': 0,
  'min_samples_split': 0,
  'min_weight_fraction_leaf': 0,
  'oob_score': 0,
  'warm_start': 0,
  'min_impurity_split': 0,
  'n_jobs': 0,
  'verbose': 0,
  'class_weight': 0,
  'ccp_alpha': 0,
  'max_samples': 0,
  'affinity': 0,
  'compute_full_tree': 0,
  'linkage': 0,
  'n_clusters': 0,
  'memory': 0,
  'connectivity': 0,
  'pooling_func': 0,
  'distance_threshold': 0,
  'compute_distances': 0,
  'accept_sparse': 0,
  'check_inverse': 0,
  'validate': 0,
  'func': 0,
  'inverse_func': 0,
  'kw_args': 0,
  'inv_kw_args': 0,
  'var_smoothing': 0,
  'priors': 0,
  'n_iter_no_change': 0,
  'subsample': 0,
  'tol': 0,
  'validation_fraction': 0,
  'init': 0,
  'alpha': 0,
  'algorithm': 0,
  'leaf_size': 0,
  'metric': 0,
  'n_neighbors': 0,
  'p': 0,
  'weights': 0,
  'metric_params': 0,
  'copy_X': 0,
  'fit_intercept': 0,
  'normalize': 0,
  'positive': 0,
  'C': 0,
  'dual': 0,
  'intercept_scaling': 0,
  'max_iter': 0,
  'multi_class': 0,
  'penalty': 0,
  'l1_ratio': 0,
  'solver': 0},
 {'learning_rate': 0,
  'loss': 0,
  'n_estimators': 0,
  'base_estimator': 0,
  'random_state': 0,
  'bootstrap': 0,
  'criterion': 0,
  'max_depth': 0,
  'max_features': 0,
  'max_leaf_nodes': 0,
  'min_impurity_decrease': 0,
  'min_samples_leaf': 0,
  'min_samples_split': 0,
  'min_weight_fraction_leaf': 0,
  'oob_score': 0,
  'warm_start': 0,
  'min_impurity_split': 0,
  'n_jobs': 0,
  'verbose': 0,
  'class_weight': 0,
  'ccp_alpha': 0,
  'max_samples': 0,
  'affinity': 0,
  'compute_full_tree': 0,
  'linkage': 0,
  'n_clusters': 0,
  'memory': 0,
  'connectivity': 0,
  'pooling_func': 0,
  'distance_threshold': 0,
  'compute_distances': 0,
  'accept_sparse': 0,
  'check_inverse': 0,
  'validate': 0,
  'func': 0,
  'inverse_func': 0,
  'kw_args': 0,
  'inv_kw_args': 0,
  'var_smoothing': 0,
  'priors': 0,
  'n_iter_no_change': 0,
  'subsample': 0,
  'tol': 0,
  'validation_fraction': 0,
  'init': 0,
  'alpha': 0,
  'algorithm': 0,
  'leaf_size': 0,
  'metric': 0,
  'n_neighbors': 0,
  'p': 0,
  'weights': 0,
  'metric_params': 0,
  'copy_X': 0,
  'fit_intercept': 0,
  'normalize': 0,
  'positive': 0,
  'C': 0,
  'dual': 0,
  'intercept_scaling': 0,
  'max_iter': 0,
  'multi_class': 0,
  'penalty': 0,
  'l1_ratio': 0,
  'solver': 0},
 {'learning_rate': 0,
  'loss': 0,
  'n_estimators': 0,
  'base_estimator': 0,
  'random_state': 0,
  'bootstrap': 0,
  'criterion': 0,
  'max_depth': 0,
  'max_features': 0,
  'max_leaf_nodes': 0,
  'min_impurity_decrease': 0,
  'min_samples_leaf': 0,
  'min_samples_split': 0,
  'min_weight_fraction_leaf': 0,
  'oob_score': 0,
  'warm_start': 0,
  'min_impurity_split': 0,
  'n_jobs': 0,
  'verbose': 0,
  'class_weight': 0,
  'ccp_alpha': 0,
  'max_samples': 0,
  'affinity': 0,
  'compute_full_tree': 0,
  'linkage': 0,
  'n_clusters': 0,
  'memory': 0,
  'connectivity': 0,
  'pooling_func': 0,
  'distance_threshold': 0,
  'compute_distances': 0,
  'accept_sparse': 0,
  'check_inverse': 0,
  'validate': 0,
  'func': 0,
  'inverse_func': 0,
  'kw_args': 0,
  'inv_kw_args': 0,
  'var_smoothing': 0,
  'priors': 0,
  'n_iter_no_change': 0,
  'subsample': 0,
  'tol': 0,
  'validation_fraction': 0,
  'init': 0,
  'alpha': 0,
  'algorithm': 0,
  'leaf_size': 0,
  'metric': 0,
  'n_neighbors': 0,
  'p': 0,
  'weights': 0,
  'metric_params': 0,
  'copy_X': 0,
  'fit_intercept': 0,
  'normalize': 0,
  'positive': 0,
  'C': 0,
  'dual': 0,
  'intercept_scaling': 0,
  'max_iter': 0,
  'multi_class': 0,
  'penalty': 0,
  'l1_ratio': 0,
  'solver': 0},
 [{'description': 'The dual formulation is only implemented for l2 penalty with the liblinear solver.',
   'anyOf': [{'type': 'object', 'properties': {'dual': {'enum': [False]}}},
             {'type': 'object', 'properties': {'penalty': {'enum': ['l2']}, 'solver': {'enum': ['liblinear']}}}]},
  {'description': 'The newton-cg, sag, and lbfgs solvers support only l2 or no penalties.',
   'anyOf': [{'type': 'object', 'properties': {'solver': {'not': {'enum': ['newton-cg', 'sag', 'lbfgs']}}}},
             {'type': 'object', 'properties': {'penalty': {'enum': ['l2', 'none']}}}]},
  {'description': 'The multi_class multinomial option is unavailable when the solver is liblinear.',
   'anyOf': [{'type': 'object', 'properties': {'multi_class': {'not': {'enum': ['multinomial']}}}},
             {'type': 'object', 'properties': {'solver': {'not': {'enum': ['liblinear']}}}}]}],
 {'0': 330, '1': 278, '2': 46},
 [],
 {},
 [{'description': "From /linear_model/_logistic.py:None:_check_solver, Exception: raise ValueError('Solver %s supports "
                  "only dual=False, got dual=%s' % (     solver, dual)) ",
   'anyOf': [{'type': 'object', 'properties': {'solver': {'enum': ['liblinear']}}},
             {'type': 'object', 'properties': {'dual': {'enum': [False]}}}]},
  {'description': 'From /linear_model/_logistic.py:None:_check_solver, Exception: raise ValueError(     "Solver %s '
                  'supports only \'l2\' or \'none\' penalties, got %s penalty." % (     solver, penalty)) ',
   'anyOf': [{'type': 'object', 'properties': {'solver': {'enum': ['liblinear', 'saga']}}},
             {'type': 'object', 'properties': {'penalty': {'enum': ['l2', 'none']}}}]},
  {'description': 'From /linear_model/_logistic.py:None:_check_solver, Exception: raise ValueError("penalty=\'none\' '
                  'is not supported for the liblinear solver") ',
   'anyOf': [{'type': 'object', 'properties': {'solver': {'not': {'enum': ['liblinear']}}}},
             {'type': 'object', 'properties': {'penalty': {'not': {'enum': ['none']}}}}]},
  {'description': 'From /linear_model/_logistic.py:None:_check_solver, Exception: raise ValueError(     "Only \'saga\' '
                  'solver supports elasticnet penalty, got solver={}.".format     (solver)) ',
   'anyOf': [{'type': 'object', 'properties': {'penalty': {'not': {'enum': ['elasticnet']}}}},
             {'type': 'object', 'properties': {'solver': {'enum': ['saga']}}}]},
  {'anyOf': [{'type': 'object', 'properties': {'multi_class': {'enum': ['auto']}}},
             {'type': 'object', 'properties': {'multi_class': {'not': {'enum': ['multinomial']}}}},
             {'type': 'object', 'properties': {'solver': {'not': {'enum': ['liblinear']}}}}]},
  {'description': "From /svm/_base.py:None:_get_liblinear_solver_type, Exception: raise ValueError(     'Unsupported "
                  "set of arguments: %s, Parameters: penalty=%r, loss=%r, dual=%r'      % (error_string, penalty, "
                  'loss, dual)) ',
   'anyOf': [{'type': 'object', 'properties': {'solver': {'not': {'enum': ['liblinear']}}}},
             {'allOf': [{'type': 'object', 'properties': {'penalty': {'enum': ['l1']}}},
                        {'type': 'object', 'properties': {'dual': {'enum': [False]}}}]},
             {'type': 'object', 'properties': {'penalty': {'enum': ['l2']}}}]},
  {'description': "From /linear_model/_logistic.py:LogisticRegression:fit, Exception: raise ValueError('l1_ratio must "
                  "be between 0 and 1; got (l1_ratio=%r)' %     self.l1_ratio) ",
   'anyOf': [{'type': 'object', 'properties': {'penalty': {'not': {'enum': ['elasticnet']}}}},
             {'allOf': [{'type': 'object', 'properties': {'l1_ratio': {'type': 'number'}}},
                        {'type': 'object', 'properties': {'l1_ratio': {'type': 'number', 'minimum': 0}}},
                        {'type': 'object', 'properties': {'l1_ratio': {'type': 'number', 'maximum': 1}}}]}]}],
 {'0': 254, '1': 278, '2': 53, '3': 45, '4': 40, '5': 19, '6': 14}]
